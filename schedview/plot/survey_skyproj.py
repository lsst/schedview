import datetime
from functools import partial

import astropy.units as u
import colorcet
import healpy as hp
import matplotlib as mpl
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
import skyproj
from astropy.coordinates import SkyCoord
from astropy.time import Time
from bokeh.models.ui.ui_element import UIElement
from matplotlib.figure import Figure

# Import ModelObservatory to make sphinx happy
from rubin_scheduler.scheduler.model_observatory import ModelObservatory  # noqa F401

import schedview.compute.astro
from schedview import band_column
from schedview.compute.camera import LsstCameraFootprintPerimeter
from schedview.compute.maf import compute_hpix_metric_in_bands

DEFAULT_MAP_KWARGS = {"cmap": colorcet.cm.blues}

DEFAULT_SKY_MAP_FACTORY = partial(
    skyproj.LaeaSkyproj,
    lat_0=-89.9999999999999,
    lon_0=0,
    extent=[0.0, 360.0, -90, 89],
)


def compute_circle_points(
    center_ra,
    center_decl,
    radius=90.0,
    start_bear=0,
    end_bear=360,
    step=1,
):
    """Create points along a circle or arc on a sphere

    Parameters
    ----------
    center_ra : `float`
        R.A. of the center of the circle (deg.).
    center_decl : `float`
        Decl. of the center of the circle (deg.).
    radius : float, optional
        Radius of the circle (deg.), by default 90.0
    start_bear : int, optional
        Bearing (E. of N.) of the start of the circle (deg.), by default 0
    end_bear : int, optional
        Bearing (E. of N.) of the end of the circle (deg.), by default 360
    step : int, optional
        Spacing of the points along the circle (deg.), by default 1

    Returns
    -------
    circle : `pandas.DataFrame`
        DataFrame with points in the circle.
    """
    ras = []
    decls = []

    bearing_angles = np.arange(start_bear, end_bear + step, step) * u.deg
    center_coords = SkyCoord(center_ra * u.deg, center_decl * u.deg)
    circle_coords = center_coords.directional_offset_by(bearing_angles, radius * u.deg)
    bearings = bearing_angles.value.tolist()
    ras = circle_coords.ra.deg.tolist()
    decls = circle_coords.dec.deg.tolist()

    # de-normalize RA so there are no large jumps, which can
    # confuse cartopy + matplotlib

    previous_ra = ras[0]
    for ra_index in range(1, len(ras)):
        if ras[ra_index] - previous_ra > 180:
            ras[ra_index] -= 360
        if ras[ra_index] - previous_ra < -180:
            ras[ra_index] += 360
        previous_ra = ras[ra_index]

    circle = pd.DataFrame(
        {
            "bearing": bearings,
            "ra": ras,
            "decl": decls,
        }
    ).set_index("bearing")

    return circle


def map_healpix(map_hpix, model_observatory, night_events, axes=None, sky_map_factory=None, **kwargs):
    """Plots visits over a healpix map, with astronomical annotations.

    Parameters
    ---------
    map_hpix : `numpy.ndarray`
        The healpixel array to show.
    model_observatory : `ModelObservatory`
        The model observatory.
    night_events : `pandas.DataFrame`
        A table of almanac events for the night, as generated by
        `schedview.compute.astro.night_events`.
    axes : `matplotlib.axes._axes.Axes`
        A matplotlib set of axes.
    sky_map_factory : `skyproj.skyproj.LaeaSkyproj` or `skyproj.McBrydeSkyproj`
        Factory to make sky_map instances
    **kwargs
        Additional keyword arguments are passed to
        `skyproj.skyproj.LaeaSkyproj.draw_hpxmap`.

    Returns
    -------
    axes : `skyproj.LaeaSkyproj`
        The skyproj projection map.
    """

    if sky_map_factory is None:
        sky_map_factory = DEFAULT_SKY_MAP_FACTORY
    assert sky_map_factory is not None

    if axes is None:
        fig = plt.figure()
        axes = fig.add_subplot(1, 1, 1)

    # skyproj.LaeaSkyproj cannot handle a max decl extent of excactly 90,
    # but it is not important for us to get particularly close.
    # It also cannot handle lat_0 of exactly -90, but seems to need it to
    # be very close to run without throwing an exception.
    sky_map = sky_map_factory(ax=axes)

    hpxmap_kwargs = {"cmap": colorcet.cm.blues}
    hpxmap_kwargs.update(kwargs)
    sky_map.draw_hpxmap(map_hpix, zoom=False, **hpxmap_kwargs)

    # Ecliptic
    ecliptic_pole = SkyCoord(lon=0 * u.degree, lat=90 * u.degree, frame="geocentricmeanecliptic").icrs
    points_on_ecliptic = compute_circle_points(ecliptic_pole.ra.deg, ecliptic_pole.dec.deg)
    sky_map.draw_polygon(points_on_ecliptic.ra, points_on_ecliptic.decl, edgecolor="green")

    # Galactic plane
    galactic_pole = SkyCoord(l=0 * u.degree, b=90 * u.degree, frame="galactic").icrs
    points_on_galactic_plane = compute_circle_points(galactic_pole.ra.deg, galactic_pole.dec.deg)
    sky_map.draw_polygon(points_on_galactic_plane.ra, points_on_galactic_plane.decl, edgecolor="blue")

    # Sun and moon
    mjd = night_events.loc["night_middle", "MJD"]
    sun_moon_positions = model_observatory.almanac.get_sun_moon_positions(mjd)
    sun_ra = np.degrees(sun_moon_positions["sun_RA"].item())
    sun_decl = np.degrees(sun_moon_positions["sun_dec"].item())
    sky_map.ax.scatter(sun_ra, sun_decl, color="yellow")

    moon_ra = np.degrees(sun_moon_positions["moon_RA"])
    moon_decl = np.degrees(sun_moon_positions["moon_dec"])
    sky_map.ax.scatter(moon_ra, moon_decl, color="orange")

    # Night limit horizons
    latitude = model_observatory.site.latitude
    zd = 70
    evening = compute_circle_points(night_events.loc["sun_n12_setting", "LST"], latitude, zd, 180, 360)
    sky_map.ax.plot(evening.ra, evening.decl, color="red", linestyle="dashed")
    evening = compute_circle_points(night_events.loc["sun_n12_setting", "LST"], latitude, zd, 0, 180)
    sky_map.ax.plot(evening.ra, evening.decl, color="red", linestyle="dotted")

    morning = compute_circle_points(night_events.loc["sun_n12_rising", "LST"], latitude, zd, 0, 180)
    sky_map.ax.plot(morning.ra, morning.decl, color="red", linestyle="dashed")
    morning = compute_circle_points(night_events.loc["sun_n12_rising", "LST"], latitude, zd, 180, 360)
    sky_map.ax.plot(morning.ra, morning.decl, color="red", linestyle="dotted")
    return sky_map


def map_visits_over_healpix(visits, map_hpix, model_observatory, night_events, axes=None, **kwargs):
    """Plots visits over a healpix map, with astronomical annotations.

    Parameters
    ---------
    visits : `pd.DataFrame`
        A DataFrame of visits, with columns ``fieldRA`` and ``fieldDec``,
        with the coordinates (in degrees), ``observationStartMJD`` with the
        MJD of the start of each visit, and ``band`` with the band
        (as a string).
    map_hpix : `numpy.ndarray`
        The healpixel array to show.
    model_observatory : `ModelObservatory`
        The model observatory.
    night_events : `pandas.DataFrame`
        A table of almanac events for the night, as generated by
        `schedview.compute.astro.night_events`.
    axes : `matplotlib.axes._axes.Axes`
        A matplotlib set of axes.
    **kwargs
        Additional keyword arguments are passed to
        `skyproj.skyproj.LaeaSkyproj.draw_hpxmap`.

    Returns
    -------
    axes : `matplotlib.axes._axes.Axes`
        A matplotlib set of axes.
    """
    sky_map = map_healpix(map_hpix, model_observatory, night_events, axes=axes, **kwargs)

    camera_perimeter = LsstCameraFootprintPerimeter()
    ras, decls = camera_perimeter(visits.fieldRA, visits.fieldDec, visits.rotSkyPos)

    for visit_ras, visit_decls in zip(ras, decls):
        sky_map.draw_polygon(visit_ras, visit_decls, edgecolor="black", linewidth=0.2)

    return sky_map.ax


def _map_grid_columns(hpix_maps, num_rows):
    # Python's "//" operator rounds down, but we want to round up, so
    # apply it to the negative, then negate the result.
    num_columns = -(-len(hpix_maps) // num_rows)
    return num_columns


def _map_grid_figure(num_rows, num_columns):
    plot_height = 5 * num_rows
    plot_width = 5.1 * num_columns
    fig = plt.figure(figsize=(plot_width, plot_height))

    return fig


def _map_grid_bands(hpix_maps):
    present_bands = hpix_maps.keys()
    # Bands should be in wavelength order for standard bands, and the rest
    # should come after in alphabetical order.
    bands = [b for b in "ugrizy" if b in present_bands] + sorted(
        b for b in present_bands if b not in "ugrizy"
    )
    return bands


def create_hpix_visit_map_grid(
    visits, hpix_maps, model_observatory, night_events, fig=None, num_rows=2, **kwargs
):
    """Plot an array of visits over a healpix maps, with astronomical
    annotations.

    Parameters
    ---------
    visits : `pd.DataFrame`
        A DataFrame of visits, with columns ``fieldRA`` and ``fieldDec``,
        with the coordinates (in degrees), ``observationStartMJD`` with the
        MJD of the start of each visit, and ``band`` with the band
        (as a string).
    hpix_maps : `dict` [`str`, `numpy.ndarray`]
        The healpixel array to show.
    model_observatory : `ModelObservatory`
        The model observatory.
    night_events : `pandas.DataFrame`
        A table of almanac events for the night, as generated by
        `schedview.compute.astro.night_events`.
    fig : `matplotlib.figure.Figure` or `None`
        A matplotlib figure in which to plot the array of maps.
        If None, a new figure is created.
        Defaults to None.
    nrows : `int`
        The number of rows in the array of plots.
        Defaults to 2.
    **kwargs
        Additional keyword arguments are passed to
        `skyproj.skyproj.LaeaSkyproj.draw_hpxmap`.

    Returns
    -------
    fig : `matplotlib.figure.Figure`
        The matplotlib figure with the array of maps.
    """
    num_columns = _map_grid_columns(hpix_maps, num_rows)
    bands = _map_grid_bands(hpix_maps)
    if fig is None:
        fig = _map_grid_figure(num_rows, num_columns)

    for band_idx, band in enumerate(bands):
        visits_in_band = visits.query(f"{band_column(visits)} == '{band}'")
        axes = fig.add_subplot(num_rows, num_columns, band_idx + 1)
        axes.set_title(band, loc="left")
        new_axes = map_visits_over_healpix(
            visits_in_band, hpix_maps[band], model_observatory, night_events, axes=axes, **kwargs
        )
        new_axes.set_title(band, loc="left")

    return fig


def create_hpix_map_grid(hpix_maps, model_observatory, night_events, fig=None, num_rows=2, **kwargs):
    """Plot an array of visits over a healpix maps, with astronomical
    annotations.

    Parameters
    ---------
    hpix_maps : `dict` [`str`, `numpy.ndarray`]
        The healpixel array to show.
    model_observatory : `ModelObservatory`
        The model observatory.
    night_events : `pandas.DataFrame`
        A table of almanac events for the night, as generated by
        `schedview.compute.astro.night_events`.
    fig : `matplotlib.figure.Figure` or `None`
        A matplotlib figure in which to plot the array of maps.
        If None, a new figure is created.
        Defaults to None.
    nrows : `int`
        The number of rows in the array of plots.
        Defaults to 2.
    **kwargs
        Additional keyword arguments are passed to
        `skyproj.skyproj.LaeaSkyproj.draw_hpxmap`.

    Returns
    -------
    fig : `matplotlib.figure.Figure`
        The matplotlib figure with the array of maps.
    """
    num_columns = _map_grid_columns(hpix_maps, num_rows)
    bands = _map_grid_bands(hpix_maps)
    if fig is None:
        fig = _map_grid_figure(num_rows, num_columns)

    for band_idx, band in enumerate(bands):
        axes = fig.add_subplot(num_rows, num_columns, band_idx + 1)
        axes.set_title(band, loc="left")
        new_axes = map_healpix(hpix_maps[band], model_observatory, night_events, axes=axes, **kwargs).ax
        new_axes.set_title(band, loc="left")

    return fig


def create_metric_map_grid(metric, visits, observatory, nside=32, **kwargs) -> Figure | UIElement | None:
    """Create a grid of maps of metric values with visits overplotted.

    Parameters
    ----------
    metric : `numpy.array`
        An array of healpix values
    visits : `pd.DataFrame`
        The visits to use to compute the metric
    observatory : `ModelObservatory`
        The model observotary to use.
    nside : `int`
        The nside with which to compute the metric.

    Returns
    -------
    fig : `matplotlib.figure.Figure`
        The matplotlib figure with the array of maps.
    """

    if len(visits):
        metric_hpix = compute_hpix_metric_in_bands(visits, metric, nside=nside)
    else:
        metric_hpix = {b: np.zeros(hp.nside2npix(nside)) for b in visits[band_column(visits)].unique()}

    day_obs_mjd = np.floor(observatory.mjd - 0.5).astype("int")
    day_obs_dt = Time(day_obs_mjd, format="mjd").datetime
    day_obs_date = datetime.date(day_obs_dt.year, day_obs_dt.month, day_obs_dt.day)
    night_events = schedview.compute.astro.night_events(day_obs_date)
    fig = create_hpix_map_grid(metric_hpix, observatory, night_events, **kwargs)
    return fig


def map_count_healpix(
    *args,
    num_colors: int = 6,
    cmap: str | mpl.colors.Colormap = "cividis_r",
    clip: bool = True,
    colorbar: bool = True,
    **kwargs,
) -> skyproj.skyproj.LaeaSkyproj:
    """Plot a healpix map appropriate when values are low integers greater
    than zero.

    Parameters
    ----------
    *args
        Positional arguments forwarded to :func:`map_healpix`.  Usually
        ``map_hpix``, ``model_observatory``, ``night_events`` and an optional
        ``axes`` instance.
    num_colors : `int`, optional
        Maximum number of integers.
        Defaults to 6.
    cmap : 'str' or `matplotlib.colors.Colormap`, optional
        Colormap name or instance to use for the discrete bins. If a string,
        the colormap is obtained via ``plt.get_cmap(cmap, num_colors)``.
    clip : `bool`, optional
        If ``True`` (default), values above the highest bin are clipped
        and the colorbar shows a “+” suffix for the final tick label.
    **kwargs
        Additional keyword arguments forwarded to :func:`map_healpix`.

    Returns
    -------
    sky_map : `skyproj.skyproj.LaeaSkyproj`
        The sky projection object with the healpix map drawn and a colorbar
        added.  The map is displayed with discrete colors corresponding to
        the specified number of bins.
    """
    if isinstance(cmap, str):
        cmap = plt.get_cmap(cmap, num_colors)

    norm = mpl.colors.BoundaryNorm(np.arange(num_colors + 1) + 0.5, ncolors=num_colors, clip=clip)

    sky_map = map_healpix(*args, cmap=cmap, norm=norm, **kwargs)

    if colorbar:
        ticks = 1 + np.arange(num_colors)
        cbar = sky_map.draw_colorbar(ticks=ticks, location="bottom", pad=0.1)

        if clip:
            cbar_ticks_labels = [t.get_text() for t in cbar.ax.get_xticklabels()]
            cbar_ticks_labels[-1] = cbar_ticks_labels[-1] + "+"
            cbar.set_ticks(ticks, labels=cbar_ticks_labels)

    return sky_map
